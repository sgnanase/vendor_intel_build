#!/usr/bin/python

import tempfile
import argparse
import binascii

import verified_boot_common as vbc
import bootimg_sig_struct as bss
from pyasn1.type import univ
from pyasn1.error import PyAsn1Error
from pyasn1.codec.der import encoder as der_encoder
from pyasn1.codec.ber import decoder as ber_decoder
from pyasn1_modules import rfc2459 as x509
from pyasn1_modules import rfc2437 as pkcs1
from pyasn1_modules import pem

DIGEST_SIG_OID_MAP = {
    "sha1": bss.sha1WithRSAEncryptionOID,
    "sha256": bss.sha256WithRSAEncryptionOID
}


class CertificateException(Exception):
    def __init__(self, msg):
        self.msg = msg


# This is uuuuugly, but it works.
# Experiment for later: Can the x509.Certificate template be tweaked prior to
#  parsing to treat subjectPublicKey as an OctetString, but use the BitString
#  tag?
def bitstringToOctets(bitstring):
    octets = 0
    for bit in bitstring:
        octets = octets << 1 | bit

    width = octets.bit_length()
    width += 8 - ((width % 8) or 8)
    fmt = '%%0%dx' % (width // 4)
    s = binascii.unhexlify(fmt % octets)
    return s


def processCertData(bag, certdata, source_filename):
    try:
        parsed_cert, remaining = ber_decoder.decode(certdata, asn1Spec = x509.Certificate())
    except PyAsn1Error:
        raise CertificateException("'%s' does not contain a valid certificate." % source_filename)

    # Extract the subject public key
    subject_key_info = parsed_cert['tbsCertificate']['subjectPublicKeyInfo']
    if subject_key_info['algorithm']['algorithm'] == x509.rsaEncryption:
        try:
            keybuf = bitstringToOctets(subject_key_info['subjectPublicKey'])
            parsed_key, remaining = ber_decoder.decode(keybuf, asn1Spec = pkcs1.RSAPublicKey())
        except PyAsn1Error:
            raise CertificateException("Certificate in '%s' contains an invalid RSA key." % source_filename)

        # Add the key to the bag
        algorithm_id = x509.AlgorithmIdentifier()
        algorithm_id['algorithm'] = DIGEST_SIG_OID_MAP[vbc.OPTIONS.key_digest]
        key_info = bss.KeyInfo()
        key_info['algorithm'] = algorithm_id
        key_info['keyMaterial'] = parsed_key
        bag.setComponentByPosition(len(bag), key_info)

    else:
        raise CertificateException("'%s' contains a public key that is not supported (%s)." % (source_filename, subject_key_info['algorithm']['algorithm']))
    #print parsed_cert.prettyPrint()


def main():
    argparser = argparse.ArgumentParser(
                    description='Create an Android verified boot keystore.')
    argparser.add_argument("keystore_file", help="Keystore to create.")
    argparser.add_argument("certs", metavar="cert", nargs="+", help="Certificate to add.")
    argparser.add_argument("--digest",
                           choices=["sha1", "sha256"], default="sha256",
                           help="Digest algorithm used for keystore signture.")
    argparser.add_argument("--key-digest",
                           choices=["sha1", "sha256"], default="sha256",
                           help="Digest algorithm used for verifying signatures using keystore.")
    argparser.add_argument("--privkey", required=True,
                           help="Private key used to sign the keystore.")
    argparser.add_argument("-v", "--verbose", action="store_true",
                           help="Show debug info and commands being run.")
    argparser.parse_args(namespace=vbc.OPTIONS)

    try:
        bag = bss.KeyBag()

        # Build a KeyBag from the set of input certs
        for cert_filename in vbc.OPTIONS.certs:
            with open(cert_filename, "rb") as incert:
                if cert_filename.lower().endswith(".pem"):
                    # A PEM file may contain one or more certificates
                    idx, certdata = pem.readPemBlocksFromFile(incert,
                                                              ("-----BEGIN CERTIFICATE-----",
                                                               "-----END CERTIFICATE-----"))
                    while idx != -1:
                        processCertData(bag, certdata, cert_filename)
                        idx, certdata = pem.readPemBlocksFromFile(incert,
                                                                  ("-----BEGIN CERTIFICATE-----",
                                                                   "-----END CERTIFICATE-----"))
                else:
                    certdata = incert.read()
                    processCertData(bag, certdata, cert_file)
        #print bag.prettyPrint()

        # Sign the KeyBag
        with tempfile.NamedTemporaryFile() as bagfile:
            inner = bss.InnerKeystore()
            inner['formatVersion'] = 0
            inner['bag'] = bag
            inner_encoded = der_encoder.encode(inner)
            bagfile.write(inner_encoded)
            bagfile.flush()

            # Sign the candidate blob
            sigval = vbc.DoSign(bagfile.name, vbc.OPTIONS.privkey, vbc.OPTIONS.digest)

        # Build signed keystore structure
        sigalg = x509.AlgorithmIdentifier()
        sigalg['algorithm'] = DIGEST_SIG_OID_MAP[vbc.OPTIONS.digest]
        attributes = bss.AuthenticatedAttributes()
        attributes["target"] = "keystore"
        attributes["length"] = len(inner_encoded)
        signature = bss.AndroidVerifiedBootSignature()
        signature['formatVersion'] = 0
        signature['algorithmId'] = sigalg
        signature['attributes'] = attributes
        signature['signature'] = sigval
        keystore = bss.AndroidVerifiedBootKeystore()
        keystore['formatVersion'] = 0
        keystore['bag'] = bag
        keystore['signature'] = signature

        if vbc.OPTIONS.verbose:
            print keystore.prettyPrint()

        with open(vbc.OPTIONS.keystore_file, "wb") as keystore_file:
            keystore_file.write(der_encoder.encode(keystore))

    except Exception as e:
        raise
        print "Error: %s" % e.msg
        return -1


if __name__ == "__main__":
    main()
